# -*- coding: utf-8 -*-
"""crucigrama_nicolas_canese.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZoCSZ9HVG8xU2rxzr1SQt_cAwpLLJ8u_
"""

import numpy as np
import math
import random
import matplotlib.pyplot as plt
import pandas as pd


#definimos variables globales
cant_h=5 #Cant. de palabras horizontales
cant_v=5 #Cant. de palabras verticales
dim=10 #Dimensión de la matriz nxn
cruci_pala=np.zeros((dim,dim), dtype=int) 
palabras_h=[]*cant_h
palabras_v=[]*cant_v


#Leemos el diccionario 
dicc_total= pd.read_csv('https://drive.google.com/u/0/uc?id=1sWivr9cyIW33k989v9VXHqCp_TBoZx0L&export=download',
                        header=None,index_col=0, squeeze=True, encoding='latin-1').to_dict()
dicc_lista=list(dicc_total.keys()) #Armamos una lista para iterar el dicc.
dicc_letras={}

#creamos sub listas con palabras con cantidad de letras menores o iguales 
#a la dimensión y mayores a 2 letas.
for i in range(2, dim+1):
  dicc_letras['letras_'+str(i)] = [j for j in dicc_lista if len(j) == i]


#Determinamos al azar la posición inicial de cada palabra
rng = np.random.default_rng()
#Primero las posiciones de inicio de las palabras horizontales
for i in range(cant_h):
    pos_h_x= rng.choice(dim-1,size=cant_h,replace=False)
    pos_h_y= rng.choice(dim-1,size=cant_h,replace=False)
    pos_h= list(zip(pos_h_x,pos_h_y))


#Condicionamos para que las palabras verticales no comienzen lejos de las horizontales
k=1
m=1
while k==1 & m==1:
  for l in range(cant_v):
    pos_v_x= rng.choice(dim-1,size=cant_v,replace=False)
    pos_v_y= rng.choice(dim-1,size=cant_v,replace=False)
    pos_v= list(zip(pos_v_x,pos_v_y))
  for i in range(cant_v):
    for j in range(cant_h):
      if pos_v[i][1]<pos_h[j][1]:
        k=1
      else: k=0
  for i in range(cant_v):
    for j in range(cant_h):
      if pos_v[i][0]<pos_h[j][0]:
        m=1
      else: m=0
          
    else:break


#determinamos la longitud de cada palabra hasta el extremo del crucigrama
len_h=np.zeros(cant_h).astype(int)
for i in range(cant_h):
  len_h[i]=10-pos_h[i][1]
len_v=np.zeros(cant_v).astype(int)
for i in range(cant_v):
  len_v[i]=10-pos_v[i][0]

                
#Creamos crucigrama con las posiciones y otro para las palabras
cruci_posc_h = np.zeros((dim,dim), dtype=int)
cruci_posc_v = np.zeros((dim,dim), dtype=int)


#Cargamos con 1s donde irían las palabras
for i in range(cant_h):
  for j in range(len_h[i]):
    cruci_posc_h[pos_h[i][0]][pos_h[i][1]+j] = 1
          
for i in range(cant_v):
  for j in range(len_v[i]):
    cruci_posc_v[pos_v[i][0]+j][pos_v[i][1]] = 1

cruci_posc = cruci_posc_h + cruci_posc_v
cruci_pala = cruci_posc.copy()
cruci_pala = cruci_posc.astype(str)
cruci_pala_while = cruci_pala.copy()


#Buscamos palabras horizontales con las longitudes dadas
def pala_hor():
  palabras_h=[]*cant_h
  for i in range(cant_h):
    palabras_h.append(dicc_letras["letras_"+
    str(len_h[i])][random.randint(0, len(dicc_letras["letras_"+str(len_h[i])])-1)])

  #colocamos las palabras horizontales en el crucigrama 
  for i in range(cant_h):
    for j in range(len_h[i]):
      cruci_pala[pos_h[i][0]][pos_h[i][1]+j] = palabras_h[i][j]


#buscamos palabras verticales
def pala_vert():
  for i in range(cant_v):
    pala_inter=[]*len_v[i]
    dicc_palabras_v=dicc_letras["letras_"+str(len_v[i])]
    for j in range(len_v[i]):
      pala_inter.append(cruci_pala[pos_v[i][0]+j][pos_v[i][1]])

    #Buscamos palabras que tengan letras en las posiciones de la interseccion con las horizontales
    posc_inter= [x for x in range(len_v[i]) if pala_inter[x]!='1']
    for a in posc_inter:
      dicc_palabras_v = [x for x in dicc_palabras_v if x[a] == pala_inter[a]]

    #Colocamos en el crucigrama las palabras encontradas 
    if len(dicc_palabras_v)!=0: 
      palabra_v=dicc_palabras_v[random.randint(0,len(dicc_palabras_v)-1)]
      palabras_v.append(palabra_v)
      for e in range(len_v[i]):
        cruci_pala[pos_v[i][0]+e][pos_v[i][1]] = palabra_v[e]
    else: pala_vert


#Mientras que el crucigrama no esté completo, se vuelve a buscar
while "1" in cruci_pala:
  pala_hor() 
  pala_vert()
  if "1" in cruci_pala:
    cruci_pala=cruci_pala_while.copy() #vuelve al crucigrama con 1s para buscar nuevas palabras


#Extraemos nuevamente las palabras, ya que si se iteró más de 1 vez,
#Hay más de 5 palabras en las listas de palabras horizontales y verticales

palabras_h=[0]*cant_h
palabras_v=[0]*cant_v 

pala_final_h=[]*cant_h
pala_final_v=[]*cant_v

for i in range(cant_h):
    for j in range(len_h[i]):
      pala_final_h.append(cruci_pala[pos_h[i][0]][pos_h[i][1]+j])
    palabras_h[i]=''.join(pala_final_h)
    pala_final_h.clear()

for i in range(cant_v):
    for j in range(len_v[i]):
      pala_final_v.append(cruci_pala[pos_v[i][0]+j][pos_v[i][1]])
    palabras_v[i]=''.join(pala_final_v)
    pala_final_v.clear()


#dibujamos el crucigrama
colores = np.empty([dim,dim], dtype=object)
for i in range(dim):
    for j in range(dim):
      if cruci_pala[i,j] == '0':
        colores[i,j] = "#000000"
      else:
        colores[i,j] = "#FFFFFF"
fig, ax = plt.subplots() 
ax.set_axis_off() 
table = ax.table( 
      cellText = cruci_pala, 
      cellColours = colores,
      cellLoc ='center',  
      loc ='upper left')   
table.set_fontsize(25)
table.scale(1.3, 3)
plt.show() 


#preparamos una tabla con los valores del crucigrama
palabras=palabras_h + palabras_v
significados= [dicc_total[k] for k in palabras]
dirección=["H","H","H","H","H","V","V","V","V","V"]
posicion=pos_h+pos_v
df = pd.DataFrame(list(zip(palabras, significados,dirección,posicion)),
               columns =['Palabra', 'Signifcado', 'Dirección', 'Posición inicial'])
print (df)